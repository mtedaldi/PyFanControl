#!/usr/bin/python

# A program to control the temperature inside the laser cabinet
# by controling the speed of the fan
#
# Temperature is measured by an MCP9808 connected by i2c
# Fan speed is controlled by an analog Voltage generated by an MCP4725
#
# Some Documentation can be found on 
# http://hifo-intranet.uzh.ch/wiki/infrastructure/tools/raspi
#
# Copyright Marco Tedaldi, University of Zurich, 2014
# <marco.tedaldi@gmail.com>
# 
# Goal:
# Program to control the temperature inside the cooled rack by
# adjusting the fan speed.
# What this program does:
# - checking the temperature (not implemented yet)
# - setting the DAC output voltage (not implemented yet)
# - sending emails if temperature exceeds limits (not implemented yet)
# - feeding the watchdog (not implemented yet)



# **CONFIGURATION**
# Settings, that can be changed
#
# **Hardware**
addr_t = 0x19 # i2c Address of the temperature Sensor
bus_nr = 1 # i2c bus to which the sensors are attached
# Note: Add 0x18 to the address set on A0-A3

addr_v = 0x60 # i2c Address of the DAC
# Note: Add 0x60 to the address set with A0

addr_d = 0x3E #i2c address of display

temp_warn = 26.5 # Temperature at which a warning message is issued
temp_crit = 28.0 # Temperature, at which a critical message is issued

sleeptime = 0.5 # The time between iterations of the control loop in seconds

# **Mail**
# rcp_warn: An array of addresses to send an email when the warning temperature is exceeded
rcp_warn = ['tedaldi@hifo.uzh.ch']
subj_warn = "Warning! Temperature in laser cabinet H37"
body_warn = "This is just a warning that temperature in the rack in H37 has exceeded " + str(temp_warn) + " degree C"
warn_repeat = 60*60*24 / sleeptime # Seconds after which a warning is sent again

# rcp_crit: a list of addresses to send a critical temperature warning
rcp_crit = ['tedaldi@hifo.uzh.ch']
subj_crit = "CRITICAL! Temperature in laser cabinet H37 too high!"
body_crit = "The temperature in the laser rack in H37 has exceeded CRITICAL level of " + str(temp_crit) + "degree C!"
body_crit = body_crit + "Immediate action required!"
crit_repeat = 60*20 / sleeptime # Seconds after which a critical condition warning is sent again

msg_from = 'tedaldi@hifo.uzh.ch' # apparent sender of the message
smtp_srv = 'smtp.uzh.ch' # Mail server to use to deliver the messages

# **Controller**
DAC_min = 0 # Minimal value of the DAC output
DAC_max = 4095 # Maximal value of the DAC output

temp_min = 20 # Temperature, at which the minimum value is on the DAC
temp_max = 29 # Temperature, at which the maximum value is on the DAC


# **Code **
# There should be no need to change anything below this line for configuration purposes!

# **Imports**
import sys        # writing to stderr and exiting cleanly
import syslog     # writing events to syslog
import time       # sleep()
import smbus      # access to i2c
import smtplib    # Sending the mails
from email.mime.text import MIMEText 
import threading  # putting suff into threads so it does not block other functions
import i2c_display
import get_ip

# **Functions**
# Name: send_mail
# Function: Checks if an email (warning or critical has to be sent)
def handle_email(temp, time_warn, time_crit):
    if time_warn > 0:
        time_warn = time_warn - 1
    if time_crit > 0:
        time_crit = time_crit - 1
    if temp > temp_crit:
        if time_crit == 0:
            send_mail_crit(temp)
            time_crit = 1200
    else:
        if temp > temp_warn:
            time_crit = 0
            if time_warn == 0:
                send_mail_warn(temp)
                time_warn = 86400
    return time_warn, time_crit

# Name: send_mail_warn
# Function: formats and sends the warning email
# It might be a good Idea to call this Function as a thread to prevent it from
# blocking the execution of the rest of the software.
def send_mail_warn(temp):
    msg = MIMEText(body_warn)
    msg_to = rcp_warn
    msg['Subject'] = subj_warn
    msg['From'] = msg_from
    msg['To'] = ", ".join(rcp_warn)
    send_mail(msg_to, msg)
    return 

def send_mail_crit(temp):
    msg = MIMEText(body_crit)
    msg_to = rcp_crit
    msg['Subject'] = subj_crit
    msg['From'] = msg_from
    msg['To'] = ", ".join(rcp_crit)
    send_mail(msg_to, msg)
    return

def send_mail(msg_to, msg):
    s = smtplib.SMTP(smtp_srv)
    s.sendmail(msg_from, msg_to, msg.as_string())
    s.quit()
    return


# Name: check_temperature
# Function: Read temperature from sensor
def check_temperature(bus, addr):
    temp = bus.read_word_data(addr,0x05) # Read a 16bit word from register 0x05
    # We need to byte swap and shift the output
    hi = ( temp & 0x000F ) << 4 # We throw away th upper nibble which contains status und sign!
    lo = ( temp & 0xFF00 ) >> 8 # we take the "lower" byte which contains also contains the fractionals in the lower nibble
    lo = lo / 16.0 # the lower nibble is fractions, so we "shift the decimal point"
    temp = hi + lo
    return temp


# Name: dac_write
# Function: writes the voltage value to the DAC
def dac_write(bus, address, value):
    lo = int(value & 0x00FF)
    hi = int((value & 0x0F00) >> 8)
    bus.write_byte_data(address, hi, lo)
    return


# Name: dac_sanitize_value
# Function: checks and coerces the DAC-Value into the allowed range
def sanitize_dac_value(value):
    if (value > 4095):
        value = 4095
    if (value < 0):
        value = 0
    return value


# Name: calculate_output
# Function: calculates the output value dependent on the temperature
def calculate_output(temperature):
    if temperature < temp_min:
        output = DAC_min
    else:
        if temperature > temp_max:
            output = DAC_max
        else:
            output = (((temperature - temp_min)/(temp_max - temp_min))*(DAC_max-DAC_min))+DAC_min
    return int(output)


# A class to filter the temperature values to reduce noise and increase resolution

class filtr:
    def __init__(self, nelements=16, defvalue=25):
        self.history = []
        self.f = []
        for i in range(0, nelements):
            self.history.append(defvalue)
            self.f.append(1.0)

    def filt(self, new_value):
        self.history.append(new_value)
        self.history.pop(0)
        i = 0
        fltsum = 0
        fltval = 0
        for val in self.f:
            fltsum = fltsum + self.f[i]
            fltval = fltval + (self.f[i] * self.history[i])
            i = i + 1
        new_value = fltval / fltsum
        return new_value

    def history(self):
        return self.history

    def set_filter(self, new_filt):
        self.f = new_filt
        if len(self.f) > len(self.history):
            for i in range(len(self.history), len(self.f)):
                self.history.append(self.history[i - 1])
        return


def main():
    # ***Initalize the variables***
    # The filter coefficients for the FIR-Filter
    filt_coeff = [
            -0.00406900049466597,
            0.0014901583160827512,
            0.0022278714276290482,
            0.0034863421930641913,
            0.005262349013769549,
            0.007526937975321521,
            0.010265872128229686,
            0.013462614002518912,
            0.017080624262474767,
            0.021064542544973485,
            0.025343688456984637,
            0.029828825716452217,
            0.034413765259578025,
            0.03898213878353851,
            0.04341086645098334,
            0.047573306814647984,
            0.0513458497439482,
            0.05461325635763496,
            0.05727219604594146,
            0.059236523087357246,
            0.06044200599455753,
            0.060848468662696956,
            0.06044200599455753,
            0.059236523087357246,
            0.05727219604594146,
            0.05461325635763496,
            0.0513458497439482,
            0.047573306814647984,
            0.04341086645098334,
            0.03898213878353851,
            0.034413765259578025,
            0.029828825716452217,
            0.025343688456984637,
            0.021064542544973485,
            0.017080624262474767,
            0.013462614002518912,
            0.010265872128229686,
            0.007526937975321521,
            0.005262349013769549,
            0.0034863421930641913,
            0.0022278714276290482,
            0.0014901583160827512,
            -0.00406900049466597
            ]
    time_w = 0 # Initialize the timeout for warning messages
    time_c = 0 # Initialize the timeout for repeatet crtitical messages


    ip = get_ip.get_ip() # Get the IP-Address
    bus = smbus.SMBus(bus_nr) # Make the bus object for communication with i2c devices
    i2c_display.init_display(bus, addr_d) # Initialze the display
    i2c_display.display_write_string(bus, addr_d, 0, ip) # Write the IP-Address to the first line on the display
    t = check_temperature(bus, addr_t) # Read the tempearture a first time to initialize the filter
    fv = filtr(len(filt_coeff), t) # Create the filter object
    fv.set_filter(filt_coeff) # load the coefficients into the FIR filter
    
    # DEBUG Output
    print ip
    print "1234567890123456"

# The real work is done in this loop!
    while True:
        try:
            tp = check_temperature(bus, addr_t)
            t = fv.filt(tp)
            dac_value = calculate_output(t)
            dac_write(bus, addr_v, dac_value)
            line2 = 'T:{0:2.4f}'.format(t) + ' D:{0:4d}'.format(dac_value)
            i2c_display.display_write_string(bus, addr_d, 1, line2)
            time_w, time_c = handle_email(t, time_w, time_c)
            time.sleep(sleeptime)
            print line2 + " " + str(tp) + " " + str(time_w) + " " + str(time_c)
        except KeyboardInterrupt:
            sys.stderr.write("\nReceived ctrl+c, will terminate\n")
            sys.exit()
        except:
            sys.stderr.write("An unknow error has occured! Terminating...\n")
            print "Error: ", sys.exc_info()[0]
            print "Error: ", sys.exc_info()[1]
            print "Error: ", sys.exc_info()[2]
            sys.exit(1)



if __name__ == "__main__":
    main();

