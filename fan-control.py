#!/usr/bin/python

# A program to control the temperature inside the laser cabinet
# by controling the speed of the fan
#
# Temperature is measured by an MCP9808 connected by i2c
# Fan speed is controlled by an analog Voltage generated by an MCP4725
#
# Some Documentation can be found on 
# http://hifo-intranet.uzh.ch/wiki/infrastructure/tools/raspi
#
# Copyright Marco Tedaldi, University of Zurich, 2014
# <marco.tedaldi@gmail.com>
# 
# Goal:
# Program to control the temperature inside the cooled rack by
# adjusting the fan speed.
# What this program does:
# - checking the temperature (not implemented yet)
# - setting the DAC output voltage (not implemented yet)
# - sending emails if temperature exceeds limits (not implemented yet)
# - feeding the watchdog (not implemented yet)



# **CONFIGURATION**
# Settings, that can be changed
#
# **Hardware**
addr_t = 0x19 # i2c Address of the temperature Sensor
bus = 1 # i2c bus to which the sensors are attached
# Note: Add 0x18 to the address set on A0-A3

addr_v = 0x60 # i2c Address of the DAC
# Note: Add 0x60 to the address set with A0

temp_warn = 25.5 # Temperature at which a warning message is issued
temp_crit = 28.0 # Temperature, at which a critical message is issued

# **Mail**
# rcp_warn: An array of addresses to send an email when the warning temperature is exceeded
rcp_warn = ['tedaldi@hifo.uzh.ch', 'kasper@hifo.uzh.ch']
subj_warn = "Warning! Temperature in laser cabinet H37"
body_warn = "This is just a warning that temperature in the rack in H37 has exceeded " + str(temp_warn) + " degree C"
warn_repeat = 60*60*24 # Seconds after which a warning is sent again

# rcp_crit: a list of addresses to send a critical temperature warning
rcp_crit = ['tedaldi@hifo.uzh.ch', 'kasper@hifo.uzh.ch']
subj_crit = "CRITICAL! Temperature in laser cabinet H37 too high!"
body_crit = "The temperature in the laser rack in H37 has exceeded CRITICAL level of " + str(temp_crit) + "degree C!"
body_crit = body_crit + "Immediate action required!"
crit_repeat = 60*20 # Seconds after which a critical condition warning is sent again

msg_from = 'tedaldi@hifo.uzh.ch' # apparent sender of the message
smtp_srv = 'smtp.uzh.ch' # Mail server to use to deliver the messages

# **Controller**
DAC_min = 0 # Minimal value of the DAC output
DAC_max = 4095 # Maximal value of the DAC output

temp_min = 20 # Temperature, at which the minimum value is on the DAC
temp_max = 29 # Temperature, at which the maximum value is on the DAC


# **Code **
# There should be no need to change anything below this line for configuration purposes!

# **Imports**
import sys        # writing to stderr and exiting cleanly
import syslog     # writing events to syslog
import time       # sleep()
import smbus      # access to i2c
import smtplib    # Sending the mails
from email.mime.text import MIMIText 
import threading  # putting suff into threads so it does not block other functions

# **Functions**
# Name: send_mail
# Function: Checks if an email (warning or critical has to be sent)
def handle_email(temp, time_warn, time_crit):
	if time_warn > 0:
		time_warn = time_warn - 1
	if time_crit > 0:
		time_crit = time_crit - 1
	if temp > temp_crit:
		if time_crit = 0:
			send_mail_crit(temp)
	else:
		if temp > temp_warn:
			time_crit = 0
			if time_warn = 0:
				send_mail_warn(temp)
	return

def send_mail_warn(temp):
	msg = MIMEText(body_warn)
	msg_to = rcp_warn
	msg['Subject'] = subj_warn
	msg['From']


# Name: check_temperature
# Function: Read temperature from sensor
def check_temperature(addr):
	temp = bus.read_word_data(addr,0x05) # Read a 16bit word from register 0x05
	# We need to byte swap and shift the output
	hi = ( temp & 0x000F ) << 4 # We throw away th upper nibble which contains status und sign!
	lo = ( temp & 0xFF00 ) >> 8 # we take the "lower" byte which contains also contains the fractionals in the lower nibble
	lo = lo / 16.0 # the lower nibble is fractions, so we "shift the decimal point"
	temp = hi + lo
	return temp


# Name: dac_write
# Function: writes the voltage value to the DAC
def dac_write(bus, address, value):
	lo = int(value & 0x00FF)
	hi = int((value & 0x0F00) >> 8)
	bus.write_byte_data(address, hi, lo)
	return


# Name: dac_sanitize_value
# Function: checks and coerces the DAC-Value into the allowed range
def sanitize_dac_value(value):
	if (value > 4095):
		value = 4095
	if (value < 0):
		value = 0
	return value


# Name: calculate_output
# Function: calculates the output value dependent on the temperature
def calculate_output(temperature):
	if temperature < temp_min:
		output = DAC_min
	else:
		if temperature > temp_max:
			output = DAC_max
		else:
			output = (((temperature - temp_min)/(temp_max - temp_min))*(DAC_max-DACmin))+DAC_min
			output = 2047
	return output



