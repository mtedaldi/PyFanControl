#!/usr/bin/python

# A program to control the temperature inside the laser cabinet
# by controling the speed of the fan
#
# Temperature is measured by an MCP9808 connected by i2c
# Fan speed is controlled by an analog Voltage generated by an MCP4725
#
# Some Documentation can be found on 
# http://hifo-intranet.uzh.ch/wiki/infrastructure/tools/raspi
#
# Copyright Marco Tedaldi, University of Zurich, 2014
# <marco.tedaldi@gmail.com>
# 
# Goal:
# Program to control the temperature inside the cooled rack by
# adjusting the fan speed.
# What this program does:
# - checking the temperature (not implemented yet)
# - setting the DAC output voltage (not implemented yet)
# - sending emails if temperature exceeds limits (not implemented yet)
# - feeding the watchdog (not implemented yet)



# **CONFIGURATION**
# Settings, that can be changed
#
# **Hardware**
addr_t = 0x19 # i2c Address of the temperature Sensor
bus_nr = 1 # i2c bus to which the sensors are attached
# Note: Add 0x18 to the address set on A0-A3

addr_v = 0x60 # i2c Address of the DAC
# Note: Add 0x60 to the address set with A0

addr_d = 0x3E #i2c address of display

temp_warn = 26.5 # Temperature at which a warning message is issued
temp_crit = 28.0 # Temperature, at which a critical message is issued

# **Mail**
# rcp_warn: An array of addresses to send an email when the warning temperature is exceeded
rcp_warn = ['tedaldi@hifo.uzh.ch', 'kasper@hifo.uzh.ch']
subj_warn = "Warning! Temperature in laser cabinet H37"
body_warn = "This is just a warning that temperature in the rack in H37 has exceeded " + str(temp_warn) + " degree C"
warn_repeat = 60*60*24 # Seconds after which a warning is sent again

# rcp_crit: a list of addresses to send a critical temperature warning
rcp_crit = ['tedaldi@hifo.uzh.ch', 'kasper@hifo.uzh.ch']
subj_crit = "CRITICAL! Temperature in laser cabinet H37 too high!"
body_crit = "The temperature in the laser rack in H37 has exceeded CRITICAL level of " + str(temp_crit) + "degree C!"
body_crit = body_crit + "Immediate action required!"
crit_repeat = 60*20 # Seconds after which a critical condition warning is sent again

msg_from = 'tedaldi@hifo.uzh.ch' # apparent sender of the message
smtp_srv = 'smtp.uzh.ch' # Mail server to use to deliver the messages

# **Controller**
DAC_min = 0 # Minimal value of the DAC output
DAC_max = 4095 # Maximal value of the DAC output

temp_min = 20 # Temperature, at which the minimum value is on the DAC
temp_max = 29 # Temperature, at which the maximum value is on the DAC


# **Code **
# There should be no need to change anything below this line for configuration purposes!

# **Imports**
import sys        # writing to stderr and exiting cleanly
import syslog     # writing events to syslog
import time       # sleep()
import smbus      # access to i2c
import smtplib    # Sending the mails
from email.mime.text import MIMEText 
import threading  # putting suff into threads so it does not block other functions
import i2c_display
import get_ip

# **Functions**
# Name: send_mail
# Function: Checks if an email (warning or critical has to be sent)
def handle_email(temp, time_warn, time_crit):
    if time_warn > 0:
        time_warn = time_warn - 1
    if time_crit > 0:
        time_crit = time_crit - 1
    if temp > temp_crit:
        if time_crit == 0:
            send_mail_crit(temp)
    else:
        if temp > temp_warn:
            time_crit = 0
            if time_warn == 0:
                send_mail_warn(temp)
    return

# Name: send_mail_warn
# Function: formats and sends the warning email
# It might be a good Idea to call this Function as a thread to prevent it from
# blocking the execution of the rest of the software.
def send_mail_warn(temp):
    msg = MIMEText(body_warn)
    msg_to = rcp_warn
    msg['Subject'] = subj_warn
    msg['From'] = msg_from
    msg['To'] = ", ".join(rcp_warn)
    send_mail(msg_to, msg)
    return 

def send_mail_crit(temp):
    msg = MIMEText(body_crit)
    msg_to = rcp_crit
    msg['Subject'] = sunj_crit
    msg['From'] = msg_from
    msg['To'] = ", ".join(rcp_crit)
    send_mail(msg_to, msg)
    return

def send_mail(msg_to, msg):
    s = smtplib.SMTP(smtp_srv)
    s.sendmail(msg_from, msg_to, msg.as_string())
    s.quit()
    return


# Name: check_temperature
# Function: Read temperature from sensor
def check_temperature(bus, addr):
    temp = bus.read_word_data(addr,0x05) # Read a 16bit word from register 0x05
    # We need to byte swap and shift the output
    hi = ( temp & 0x000F ) << 4 # We throw away th upper nibble which contains status und sign!
    lo = ( temp & 0xFF00 ) >> 8 # we take the "lower" byte which contains also contains the fractionals in the lower nibble
    lo = lo / 16.0 # the lower nibble is fractions, so we "shift the decimal point"
    temp = hi + lo
    return temp


# Name: dac_write
# Function: writes the voltage value to the DAC
def dac_write(bus, address, value):
    lo = int(value & 0x00FF)
    hi = int((value & 0x0F00) >> 8)
    bus.write_byte_data(address, hi, lo)
    return


# Name: dac_sanitize_value
# Function: checks and coerces the DAC-Value into the allowed range
def sanitize_dac_value(value):
    if (value > 4095):
        value = 4095
    if (value < 0):
        value = 0
    return value


# Name: calculate_output
# Function: calculates the output value dependent on the temperature
def calculate_output(temperature):
    if temperature < temp_min:
        output = DAC_min
    else:
        if temperature > temp_max:
            output = DAC_max
        else:
            output = (((temperature - temp_min)/(temp_max - temp_min))*(DAC_max-DAC_min))+DAC_min
    return int(output)


# A class to filter the temperature values to reduce noise and increase resolution

class filtr:
    def __init__(self, nelements=16, defvalue=25):
        self.history = []
        self.f = []
        for i in range(0, nelements):
            self.history.append(defvalue)
            self.f.append(1.0)

    def filt(self, new_value):
        self.history.append(new_value)
        self.history.pop(0)
        i = 0
        fltsum = 0
        fltval = 0
        for val in self.f:
            fltsum = fltsum + self.f[i]
            fltval = fltval + (self.f[i] * self.history[i])
            i = i + 1
        new_value = fltval / fltsum
        return new_value

    def history(self):
        return self.history

    def set_filter(self, new_filt):
        self.f = new_filt
        return


def main():
    filt_coeff = [
            0.005836310228843315,
            0.018235835282369148,
            0.026122022209528667,
            0.04327394282699852,
            0.05959485293788556,
            0.07821170914051696,
            0.09491593851808021,
            0.10895605062142762,
            0.1179999319917522,
            0.12122948160286849,
            0.1179999319917522,
            0.10895605062142762,
            0.09491593851808021,
            0.07821170914051696,
            0.05959485293788556,
            0.04327394282699852,
            0.026122022209528667,
            0.018235835282369148,
            0.005836310228843315
            ]
    time_w = 0
    time_c = 0
    fv = filtr(19, 25)
    fv.set_filter(filt_coeff)
    ip = get_ip.get_ip()
    bus = smbus.SMBus(bus_nr)
    i2c_display.init_display(bus, addr_d)
    i2c_display.display_write_string(bus, addr_d, 0, ip)
    print ip
    print "1234567890123456"
    while True:
        try:
            t = check_temperature(bus, addr_t)
            t = fv.filt(t)
            dac_value = calculate_output(t)
            dac_write(bus, addr_v, dac_value)
            line2 = 'T:{0:2.4f}'.format(t) + ' D:{0:4d}'.format(dac_value)
            i2c_display.display_write_string(bus, addr_d, 1, line2)
            print line2
            handle_email(t, time_w, time_c)
            time.sleep(1)
        except KeyboardInterrupt:
            sys.stderr.write("\nReceived ctrl+c, will terminate\n")
            sys.exit()
        except:
            sys.stderr.write("An unknow error has occured! Terminating...\n")
            print "Error: ", sys.exc_info()[0]
            print "Error: ", sys.exc_info()[1]
            print "Error: ", sys.exc_info()[2]
            sys.exit(1)



if __name__ == "__main__":
    main();

