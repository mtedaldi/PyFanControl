#!/usr/bin/python3

# A program to control the temperature inside the laser cabinet
# by controling the speed of the fan
#
# Temperature is measured by an MCP9808 connected by i2c
# Fan speed is controlled by an analog Voltage generated by an MCP4725
#
# This Version should run with quickwire-i2c (because it gives more
# flexibility) and on pythone3 (because quickwire-i2c apparently needs
# it)
#
# Some Documentation can be found on 
# http://hifo-intranet.uzh.ch/wiki/infrastructure/tools/raspi
#
# Copyright Marco Tedaldi, University of Zurich, 2014
# <marco.tedaldi@gmail.com>
# License: MIT http://opensource.org/licenses/MIT
# 
# Goal:
# Program to control the temperature inside the cooled rack by
# adjusting the fan speed.
# What this program does:
# - checking the temperature
# - setting the DAC output voltage
# - sending emails if temperature exceeds limits
# - feeding the watchdog 


debug = False

# **CONFIGURATION**
# Settings, that can be changed
#
# **Hardware**
addr_t = 0x19 # i2c Address of the temperature Sensor
bus_nr = 1 # i2c bus to which the sensors are attached
# Note: Add 0x18 to the address set on A0-A3

addr_v = 0x60 # i2c Address of the DAC
# Note: Add 0x60 to the address set with A0

addr_d = 0x3E #i2c address of display

temp_warn = 26.5 # Temperature at which a warning message is issued
temp_crit = 28.0 # Temperature, at which a critical message is issued

sleeptime = 0.5 # The time between iterations of the control loop in seconds

# **Mail**
# rcp_warn: An array of addresses to send an email when the warning temperature is exceeded
rcp_warn = ['tedaldi@hifo.uzh.ch']
subj_warn = "Warning! Temperature in laser cabinet H37"
body_warn = "This is just a warning that temperature in the rack in H37 has exceeded " + str(temp_warn) + " degree C"
warn_repeat = 60*60*24 / sleeptime # Seconds after which a warning is sent again

# rcp_crit: a list of addresses to send a critical temperature warning
rcp_crit = ['tedaldi@hifo.uzh.ch']
subj_crit = "CRITICAL! Temperature in laser cabinet H37 too high!"
body_crit = "The temperature in the laser rack in H37 has exceeded CRITICAL level of " + str(temp_crit) + " degree C!"
body_crit = body_crit + "\nImmediate action required!"
crit_repeat = 60*20 / sleeptime # Seconds after which a critical condition warning is sent again

msg_from = 'tedaldi@hifo.uzh.ch' # apparent sender of the message
smtp_srv = 'smtp.uzh.ch' # Mail server to use to deliver the messages

# **Controller**
DAC_min = 0 # Minimal value of the DAC output
DAC_max = 4095 # Maximal value of the DAC output

temp_min = 20 # Temperature, at which the minimum value is on the DAC
temp_max = 29 # Temperature, at which the maximum value is on the DAC

extra_chars = [
        0x00, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, 0x00,
        0x16, 0x15, 0x15, 0x16, 0x14, 0x14, 0x00, 0x00
        ]
hb_chars = ["/", "-", chr(0x00), "|"] # characters for the hartbeat signal on display. Must be 4 chars!


# **Code **
# There should be no need to change anything below this line for configuration purposes!

# **Imports**
import sys        # writing to stderr and exiting cleanly
import syslog     # For writing data to syslog
import time       # sleep()
import smtplib    # Sending the mails
from email.mime.text import MIMEText 
import i2c_display
import get_ip
import fir
import quick2wire.i2c as i2c
import wdt

# **Functions**
# Name: send_mail
# Function: Checks if an email (warning or critical has to be sent)
def handle_email(temp, time_warn, time_crit):
    if int(time_warn) > 0:
        time_warn = time_warn - 1
    if int(time_crit) > 0:
        time_crit = time_crit - 1
    if temp > temp_crit:
        if time_crit == 0:
            send_mail_crit(temp)
            time_crit = int(crit_repeat)
    else:
        if temp > temp_warn:
            time_crit = 0
            if time_warn == 0:
                send_mail_warn(temp)
                time_warn = int(warn_repeat)
    return time_warn, time_crit

# Name: send_mail_warn
# Function: formats and sends the warning email
# It might be a good Idea to call this Function as a thread to prevent it from
# blocking the execution of the rest of the software.
def send_mail_warn(temp):
    msg = MIMEText(body_warn)
    msg_to = rcp_warn
    msg['Subject'] = subj_warn
    msg['From'] = msg_from
    msg['To'] = ", ".join(rcp_warn)
    send_mail(msg_to, msg)
    return 

def send_mail_crit(temp):
    #body_crit = body_crit + "\nTemperature: " + str(temp) + "degree C"
    msg = MIMEText(body_crit)
    msg_to = rcp_crit
    msg['Subject'] = subj_crit
    msg['From'] = msg_from
    msg['To'] = ", ".join(rcp_crit)
    send_mail(msg_to, msg)
    return

def send_mail(msg_to, msg):
    s = smtplib.SMTP(smtp_srv)
    s.sendmail(msg_from, msg_to, msg.as_string())
    s.quit()
    return


# Name: check_temperature
# Function: Read temperature from sensor
def check_temperature(bus, addr):
    bus.transaction(i2c.writing_bytes(addr,0x05)) # Read a 16bit word from register 0x05
    hi, lo = bus.transaction(i2c.reading(addr,2))[0]

    # We need to byte swap and shift the output
    sign = (hi & 0x10) # Sign of the temperature
    hi = ( hi & 0x0F ) << 4 # We throw away th upper nibble which contains status und sign!
    lo = lo / 16.0 # the lower nibble is fractions, so we "shift the decimal point"
    temp = hi + lo
    if sign != 0: # If the temperature is <0
        temp = temp - 256 # We have to fix the value thanks to 2s complement
    return temp


# Name: dac_write
# Function: writes the voltage value to the DAC
def dac_write(bus, address, value):
    lo = int(value & 0x00FF)
    hi = int((value & 0x0F00) >> 8)
    bus.transaction(i2c.writing_bytes(address, hi, lo))
    return


# Name: dac_sanitize_value
# Function: checks and coerces the DAC-Value into the allowed range
def sanitize_dac_value(value):
    if (value > 4095):
        value = 4095
    if (value < 0):
        value = 0
    return value


# Name: calculate_output
# Function: calculates the output value dependent on the temperature
def calculate_output(temperature):
    if temperature < temp_min:
        output = DAC_min
    else:
        if temperature > temp_max:
            output = DAC_max
        else:
            output = (((temperature - temp_min)/(temp_max - temp_min))*(DAC_max-DAC_min))+DAC_min
    return int(output)

def write_line1(disp, ip):
    disp.write_cgchar(0, extra_chars) # write the special characters into CGRAM
    disp.write_string(0, chr(0x01) + ip) # Write the IP-Address to the first line on the display
    return



def main():
    # ***Initalize the variables***
    # The filter coefficients for the FIR-Filter
    filt_coeff = [
            -0.00406900049466597,
            0.0014901583160827512,
            0.0022278714276290482,
            0.0034863421930641913,
            0.005262349013769549,
            0.007526937975321521,
            0.010265872128229686,
            0.013462614002518912,
            0.017080624262474767,
            0.021064542544973485,
            0.025343688456984637,
            0.029828825716452217,
            0.034413765259578025,
            0.03898213878353851,
            0.04341086645098334,
            0.047573306814647984,
            0.0513458497439482,
            0.05461325635763496,
            0.05727219604594146,
            0.059236523087357246,
            0.06044200599455753,
            0.060848468662696956,
            0.06044200599455753,
            0.059236523087357246,
            0.05727219604594146,
            0.05461325635763496,
            0.0513458497439482,
            0.047573306814647984,
            0.04341086645098334,
            0.03898213878353851,
            0.034413765259578025,
            0.029828825716452217,
            0.025343688456984637,
            0.021064542544973485,
            0.017080624262474767,
            0.013462614002518912,
            0.010265872128229686,
            0.007526937975321521,
            0.005262349013769549,
            0.0034863421930641913,
            0.0022278714276290482,
            0.0014901583160827512,
            -0.00406900049466597
            ]
    time_w = 0 # Initialize the timeout for warning messages
    time_c = 0 # Initialize the timeout for repeatet crtitical messages


    ip = get_ip.get_ip() # Get the IP-Address

    wd = wdt.wdt() # initialize the watchdog
    wd.open() # open the watchdog file (and arm the watchdog)
    wd.refresh() # give the watchdog a first kick


#    bus = smbus.SMBus(bus_nr) # Make the bus object for communication with i2c devices
    with i2c.I2CMaster(bus_nr) as bus:
        display = i2c_display.i2c_display(bus, addr_d) # Initialze the display
        display.clear() # Clear the display

        write_line1(display, ip)
        t = check_temperature(bus, addr_t) # Read the tempearture a first time to initialize the filter
        fv = fir.filtr(len(filt_coeff), t) # Create the filter object
        fv.set_filter(filt_coeff) # load the coefficients into the FIR filter
    
    # DEBUG Output
        if debug:
            print(ip)

        hb_cnt = 0
        syslog.syslog("fan-control: Program started")

# The real work is done in this loop!
        while True:
            try:
                wd.refresh() # Kick the watchdog
                # Collect
                tp = check_temperature(bus, addr_t) # read temperature

                # Process
                t = fv.filt(tp) # filter temperature
                dac_value = calculate_output(t) # calculate the DAC-Value from temperature
                line2 = 'T:{0:2.2f}'.format(t) + chr(0xDF) + 'C D:{0:4d}'.format(dac_value) # Format the information for dipslay

                # Output
                dac_write(bus, addr_v, dac_value) # write the calculate value to the DAC
                display.write_string(1, line2) # Write information to diplay
                time_w, time_c = handle_email(t, time_w, time_c) # Call the email handler

                # Write heartbeat signal
                hb_cnt = hb_cnt + 1
#                if hb_cnt >= 4:
#                    hb_cnt = 0
                display.write_xy(15, 0, hb_chars[hb_cnt % 4])

                if (hb_cnt % 600) == 0:  # Every 600 iterations (5min)
                    ip = get_ip.get_ip()
                if (hb_cnt % 20) == 0:
                    write_line1(display, ip) # Update CGRAM and IP Address

                # Wait
                time.sleep(sleeptime)

                # Debug output
                if debug:
                    print( line2 + " " + str(tp) + " " + str(time_w) + " " + str(time_c) )
            except KeyboardInterrupt:
                sys.stderr.write("\nReceived ctrl+c, will terminate\n")
                #sys.exit()
                wd.deactivate() # Disarm the watchdog
                wd.finish() # Close the file
                syslog.syslog("fan-control: Program terminated by keyboard interrupt") # Write Message to syslog
                sys.exit()
            except:
                sys.stderr.write("An unknow error has occured! Terminating...\n")
                print( "Error: ", sys.exc_info()[0])
                print( "Error: ", sys.exc_info()[1])
                print( "Error: ", sys.exc_info()[2])
                syslog.syslog(syslog.LOG_ERR, "fan-control: Terminating because of error!") # Write error to syslog
                syslog.syslog(syslog.LOG_ERR, "fan-control:" + str(sys.exc_info()[0]))
                syslog.syslog(syslog.LOG_ERR, "fan-control:" + str(sys.exc_info()[1]))
                syslog.syslog(syslog.LOG_ERR, "fan-control:" + str(sys.exc_info()[2]))
                sys.exit(1)



if __name__ == "__main__":
    main();

